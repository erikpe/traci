;;; Imports
;;; -------

(import s2j)

;;; Generic helpers
;;; ---------------

(define (add-last l e)
  (if (null? l)
      (list e)
      (cons (car l) (add-last (cdr l) e))))

(define (replace-nth n l e)
  (if (= 0 n)
      (cons e (cdr l))
      (cons (car l)
            (replace-nth (- n 1) (cdr l) e))))

;;; Vector primitives
;;; -----------------

(define (vec . args)
  (cond ((not (= 3 (length args)))
	 (error 'vec "Expected 3 arguments, got ~a" (length args)))
	((not (number? (list-ref args 0)))
	 (error 'vec "Argument 1 not a number: `~a'" (list-ref args 0)))
	((not (number? (list-ref args 1)))
	 (error 'vec "Argument 2 not a number: `~a'" (list-ref args 1)))
	((not (number? (list-ref args 2)))
	 (error 'vec "Argument 3 not a number: `~a'" (list-ref args 2)))
	(#t
	 (cons 'vec args))))

(define (vec? obj)
  (and (list? obj)
       (= 4 (length obj))
       (eq? 'vec (list-ref obj 0))
       (number? (list-ref obj 1))
       (number? (list-ref obj 2))
       (number? (list-ref obj 3))))

(define (vec-x vec)
  (if (not (vec? vec))
      (error 'vec-x "Not a vactor: `~a'" vec)
      (list-ref vec 1)))

(define (vec-y vec)
  (if (not (vec? vec))
      (error 'vec-y "Not a vactor: `~a'" vec)
      (list-ref vec 2)))

(define (vec-z vec)
  (if (not (vec? vec))
      (error 'vec-z "Not a vactor: `~a'" vec)
      (list-ref vec 3)))

;;; Shape primitives
;;; ----------------

(define (make-shape variant)
  (if (not (symbol? variant))
      (error 'make-shape "Not a symbol: `~a'" variant))
      (list 'shape variant (make-arg-list)))

(define (shape? obj)
  (and (list? obj)
       (eq? 'shape (car obj))
       (= 3 (length obj))))

(define (shape-variant shape)
  (if (not (shape? shape))
      (error 'shape-variant "Not a shape: `~a'" shape)
      (list-ref shape 1)))

(define (shape-get-arg-list shape)
  (if (not (shape? shape))
      (error 'shape-get-arg-list "Not a shape: `~a'" shape)
      (list-ref shape 2)))

(define (shape-set-arg-list shape arg-list)
  (cond ((not (shape? shape))
	 (error 'shape-set-arg-list "Argument 1 not a shape: `~a'" shape))
	((not (arg-list? arg-list))
	 (error 'shape-set-arg-list "Argument 2 not an arg-list: `~a'" arg-list))
	(#t
	 (replace-nth 2 shape arg-list))))

;;; Transform primitives
;;; --------------------

(define (make-generic-transform variant arg)
  (if (not (symbol? variant))
      (error 'make-generic-transform "Not a symbol: `~a'" variant)
      (list 'transform variant arg)))

(define (transform? obj)
  (and (list? obj)
       (= 3 (length obj))
       (eq? 'transform (car obj))))

(define (transform-variant transform)
  (if (not (transform? transform))
      (error 'transform-variant "Not a transform: `~a'" transform)
      (list-ref transform 1)))

(define (transform-argument transform)
  (if (not (transform? transform))
      (error 'transform-argument "Not a transform: `~a'" transform)
      (list-ref transform 2)))

;;; Arg-list primitives
;;; -------------------

(define (make-arg-list)
  '(arg-list))

(define (arg-list? obj)
  (and (list? obj)
       (eq? 'arg-list (car obj))))

(define (arg-list-add-arg arg-list arg)
  (cond ((not (arg-list? arg-list))
	 (error 'arg-list-add-arg "Not an arg-list: `~a'" arg-list))
	((arg-list? arg)
	 (error 'arg-list-add-arg "Attempting to insert arg-list into arg-list"))
	(#t
	 (add-last arg-list arg))))

(define (arg-list-empty? arg-list)
  (if (not (arg-list? arg-list))
      (error 'arg-list-empty? "Argument 1 not an arg-list: `~a'" arg-list)
      (null? (cdr arg-list))))

(define (arg-list-first arg-list)
  (cond ((not (arg-list? arg-list))
	 (error 'arg-list-first "Argument 1 not an arg-list: `~a'" arg-list))
	((arg-list-empty? arg-list)
	 (error 'arg-list-first "Arg-list empty"))
	(#t
	 (car (cdr arg-list)))))

(define (arg-list-rest arg-list)
  (cond ((not (arg-list? arg-list))
	 (error 'arg-list-rest "Argument 1 not an arg-list: `~a'" arg-list))
	((arg-list-empty? arg-list)
	 (error 'arg-list-rest "Arg-list empty"))
	(#t
	 (cons (car arg-list) (cdr (cdr arg-list))))))

;;; Java converter
;;; --------------

;(define-java-class <traci.math.Vector>)
;(define-java-class <traci.math.Transformation>)

;(define-java-class <traci.model.shape.csg.Union>)
;(define-java-class <traci.model.shape.csg.Difference>)
;(define-java-class <traci.model.shape.csg.Intersection>)
;(define-java-class <traci.model.shape.primitive.Sphere>)
;(define-java-class <traci.model.shape.primitive.Cylinder>)
;(define-java-class <traci.model.shape.primitive.Box>)

;(define (->jvec vec)
;  (if (not (vec? vec))
;      (error 'vec->java "Not a vector: `~a'" vec)
;      ((generic-java-method '|make|)
;       (java-null <traci.math.Vector>)
;       (->jdouble (vec-x vec))
;       (->jdouble (vec-y vec))
;       (->jdouble (vec-z vec)))))

;(define (->jshape/empty shape)
;  (let ((variant (shape-variant shape)))
;    (cond ((eq? 'union variant)
;	   (java-new <traci.model.shape.csg.Union>))
;	  ((eq? 'difference variant)
;	   (java-new <traci.model.shape.csg.Difference>))
;	  ((eq? 'intersection variant)
;	   (java-new <traci.model.shape.csg.Intersection>))
;	  ((eq? 'sphere variant)
;	   (java-new <traci.model.shape.primitive.Sphere>))
;	  ((eq? 'cylinder variant)
;	   (java-new <traci.model.shape.primitive.Cylinder>))
;	  ((eq? 'box variant)
;	   (java-new <traci.model.shape.primitive.Box>))
;	  (#t
;	   (error 'shape->java/empty "Unknown shape type: `~a'" shape)))))

;(define (->jshape shape)
;  (if (not (shape? shape))
;      (error 'shape->java "Not a shape: `~a'" shape)
;      (let ((java-shape (shape->java/empty) shape))
;	(for-each
;	 java-shape))))

;(define (get-java-transform-method variant)
;  (cond ((not (symbol? variant))
;	 (error 'get-transform-method "Not a symbol: `~a'" variant))
;	((eq? 'translate variant)
;	 (generic-java-method '|translate|))
;	((eq? 'scale variant)
;	 (generic-java-method '|scale|))
;	((eq? 'rotx variant)
;	 (generic-java-method '|rotateX|))
;	((eq? 'roty variant)
;	 (generic-java-method '|rotateY|))
;	((eq? 'rotz variant)
;	 (generic-java-method '|rotatyZ|))
;	(#t
;	 (error 'get-transform-method "Unknown transform type: `~a'" variant))))

;(define (->jtransform transform)
;  (cond ((not (transform? transform))
;	 (error 'transform->java "Not a transform: `~a'" transform))
;	((vector-transform? transform)
;	 ((get-java-transform-method (transform-variant transform))
;	  (vec->java (transform-argument transform))))
;	((scalar-transform? transform)
;	 ((get-java-transform-method (transform-variant transform))
;	  (->jdouble (transform-argument transform))))))
;	(#t
;	 (error 'transform->java "Unknown transform type: `~a'" transform))))

;;; Other stuff
;;; -----------

(define (union? shape)
  (and (shape? shape)
       (eq? 'union (shape-variant shape))))

(define (difference? shape)
  (and (shape? shape)
       (eq? 'difference (shape-variant shape))))

(define (intersection? shape)
  (and (shape? shape)
       (eq? 'intersection (shape-variant shape))))

(define (sphere? shape)
  (and (shape? shape)
       (eq? 'sphere (shape-variant shape))))

(define (cylinder? shape)
  (and (shape? shape)
       (eq? 'cylinder (shape-variant shape))))

(define (box? shape)
  (and (shape? shape)
       (eq? 'box (shape-variant shape))))

(define (primitive-shape? shape)
  (or (sphere? shape)
      (cylinder? shape)
      (box? shape)))

(define (csg-shape? shape)
  (or (union? shape)
      (difference? shape)
      (box? shape)))

(define (vector-transform? obj)
  (and (transform? obj)
       (or (eq 'translate (transform-variant obj))
	   (eq 'scale (transform-variant obj)))))

(define (scalar-transform? obj)
  (and (transform? obj)
       (or (eq 'rotx (transform-variant obj))
	   (eq 'roty (transform-variant obj))
	   (eq 'rotz (transform-variant obj)))))

(define (arg-list-merge arg-list1 arg-list2)
  (cond ((not (arg-list? arg-list1))
	 (error 'arg-list-merge "Argument 1 not an arg-list: `~a'" arg-list1))
	((not (arg-list? arg-list2))
	 (error 'arg-list-merge "Argument 2 not an arg-list: `~a'" arg-list2))
	((arg-list-empty? arg-list2)
	 arg-list1)
	(#t
	 (arg-list-merge
	  (arg-list-add-arg arg-list1 (arg-list-first arg-list2))
	  (arg-list-rest arg-list2)))))

(define (shape-add-arg outer-shape arg)
  (cond ((not (shape? outer-shape))
	 (error 'shape-add-arg "Argument 1 is not a shape: `~a'" outer-shape))
	((arg-list? arg)
	 (shape-set-arg-list outer-shape
			     (arg-list-merge (shape-get-arg-list outer-shape) arg)))
	((or (transform? arg) (shape? arg))
	 (shape-set-arg-list outer-shape
			     (arg-list-add-arg (shape-get-arg-list outer-shape) arg)))
	(#t
	 (error 'add-arg-to-shape "Argument 2 of unknown type: `~a'" arg))))

(define (generic-shape variant . args)
  (if (not (symbol? variant))
      (error 'generic-shape "Argument 1 not a symbol: `~a'" variant)
      (let ((this-shape (make-shape variant)))
	(for-each
	 (lambda (arg) (set! this-shape (shape-add-arg this-shape arg)))
	 args)
	this-shape)))

(define (generic-vector-transformation variant . args)
  (cond ((not (symbol? variant))
	 (error 'generic-vector-transformation "Argument 1 not a symbol: `~a'" variant))
	((= 3 (length args))
	 (generic-vector-transformation variant (apply vec args)))
	((not (= 1 (length args)))
	 (error variant "Expected 1 or 3 arguments, got ~a" (length args)))
	((vec? (car args))
	 (make-generic-transform variant (car args)))
	(#t
	 (error variant "Argument 1 not a vector: `~a'" (car args)))))

(define (generic-scalar-transformation variant . args)
  (cond ((not (symbol? variant))
	 (error 'generic-vector-transformation "Argument 1 not a symbol: `~a'" variant))
	((not (= 1 (length args)))
	 (error variant "Expected 1 argument, got ~a" (length args)))
	((not (number? (car args)))
	 (error variant "Argument 1 not a number: `~a'" (car args)))
	(#t
	 (make-generic-transform variant (car args)))))

;;; User functions: control functions
;;; ---------------------------------

(define (insert . args)
  (cond ((null? args)
	 (make-arg-list))
	((arg-list? (car args))
	 (arg-list-merge (car args)
			 (apply insert (cdr args))))
	(#t
	 (arg-list-merge (arg-list-add-arg (make-arg-list) (car args))
			 (apply insert (cdr args))))))

(define-syntax loop
  (syntax-rules ()
    ((_ var from to args ...)
     (do ((var from (+ 1 var))
	  (arg-list (make-arg-list)))
	 ((> var to) arg-list)
       (set! arg-list (arg-list-merge arg-list (insert args ...)))))))

;;; User functions: shapes
;;; ----------------------

(define (union . args)
  (apply generic-shape 'union args))

(define (difference . args)
  (apply generic-shape 'difference args))

(define (intersection . args)
  (apply generic-shape 'intersection args))

(define (sphere . args)
  (apply generic-shape 'sphere args))

(define (cylinder . args)
  (apply generic-shape 'cylinder args))

(define (box . args)
  (apply generic-shape 'box args))

;;; User functions: transformations
;;; -------------------------------

(define (translate . args)
  (apply generic-vector-transformation 'translate args))

(define (scale . args)
  (apply generic-vector-transformation 'scale args))

(define (rotx . args)
  (apply generic-scalar-transformation 'rotx args))

(define (roty . args)
  (apply generic-scalar-transformation 'roty args))

(define (rotz . args)
  (apply generic-scalar-transformation 'rotz args))




(define epsilon 0.0001)

(define (peg . args)
  (cylinder
   (scale .3 .1 .3)
   (translate .25 .6 .25)
   (apply insert args)))

(define (hole . args)
  (cylinder
   (scale .3 (+ (* 2 epsilon) .5) .3)
   (rotx 90)
   (translate .5 .3 (- epsilon))
   (apply insert args)))

(define (lego pegs . args)
  (union
   (difference
    (box (scale (/ pegs 2.0) .6 .5))
    (loop i 0 (- pegs 2)
          (hole (translate (* i .5) 0 0))))
   (loop i 0 (- pegs 1)
         (peg (translate (* i .5) 0 0)))
   (apply insert args)))


(define (recu n)
  (if (= 0 n) (sphere)
      (insert (recu (- n 1))
	      (recu (- n 1)))))

(display (union (recu 0)))


;(define (keso . args)
;  (union
;   (insert args)))

;(display (lego 100))
(display "\n")
