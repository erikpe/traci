#ifndef LEGO_PIECES_TRACI
#define LEGO_PIECES_TRACI

#include "lego-units.traci"
#include "lego-primitives.traci"

global DEVEL = 0;

def legopieceTechnicBrickWithHoles (length)
{
    boxLength = LU * length;
    boxHeight = LU * 1.2;
    boxWidth = LU;
    thickness = LU * .15;
    pegHeight = LU * .2;
    if (DEVEL > 0) {
        shrink = LU*.01;
        return union {
            difference {
                box {
                    scale [boxLength-2*shrink, boxHeight-2*shrink, boxWidth-2*shrink];
                    translate [1, 1, 1] * shrink;
                }
                for (i in 0 .. length-2) {
                    fastLegopartTechnicBrickHole() {
                        translate X*i*LU;
                    }
                }
            }
            for (i in 0 .. length-1) {
                fastLegopartPeg () {
                    translate [LU*i, boxHeight, 0];
                }
            }
            bbox {
                scale [boxLength, boxHeight+pegHeight, boxWidth];
            }
        }
    }
    return union {
        difference {
            roundedBox (boxLength, boxHeight, boxWidth, LEGO_ROUNDING);
            difference {
                roundedBox2 (boxLength-2*thickness, boxHeight-thickness, boxWidth-2*thickness, LEGO_ROUNDING) {
                    translate [thickness, 0, thickness];
                }
                for (i in 0 .. length-2) {
                    cylinder (LU*.3+thickness*.5, [LU, LU*.7, thickness-EPSILON], [LU, LU*.7, boxWidth-thickness+EPSILON]) {
                        translate X*LU*i;
                    }
                }
            }
            for (i in 0 .. length-2) {
                legopartTechnicBrickHole () {
                    translate X*i*LU;
                }
            }
        }
        for (i in 0 .. length-2) {
            roundedCylinder0 (LU*.15, LU*.35, LEGO_ROUNDING) {
                scale [1, -1, 1];
                translate [LU, LU*.35, LU*.5];
                translate X*LU*i;
            }
        }
        for (i in 0 .. length-1) {
            legopartPegHole () {
                translate [LU*i, boxHeight, 0];
            }
        }
        bbox {
            scale [boxLength, boxHeight+pegHeight, boxWidth];
        }
    }
}

def legopiecePlate (width, length)
{
    boxLength = length*LU;
    boxHeight = .4*LU;
    boxWidth = width*LU;
    pegHeight = .2*LU;
    return union {
        roundedBox (boxLength, boxHeight, boxWidth, LEGO_ROUNDING) {
            for (x in 0 .. length-1) {
                for (z in 0 .. width-1) {
                    legopartPeg () {
                        translate [x*LU, boxHeight, z*LU];
                    }
                }
            }
            bbox {
                scale [boxLength, boxHeight+pegHeight, boxWidth];
            }
        }
    }
}

def legopieceTechnicPlateWithHoles (length)
{
    boxLength = length*LU;
    boxHeight = .4*LU;
    boxWidth = 2*LU;
    pegHeight = .2*LU;
    return union {
        difference {
            roundedBox (boxLength, boxHeight, boxWidth, LEGO_ROUNDING);
            for (x in 0 .. length-2) {
                legopartTechnicPlateHole () {
                    translate X*(x*LU);
                }
            }
        }
        for (x in 0 .. length-1) {
            legopartPeg () {
                translate [x*LU, boxHeight, 0];
            }
            legopartPeg() {
                translate [x*LU, boxHeight, LU];
            }
        }
        bbox {
            scale [boxLength, boxHeight+pegHeight, boxWidth];
        }
    }
}

def legopieceTechnicPin0 (length)
{
    radius = LU*.3;
    outerStopperRadius = LU*.04;
    openingWidth = LU*.1;
    openingDepth = LU*.4;
    return difference {
        union {
            roundedCylinder4 (radius, length, LEGO_ROUNDING) {
                rotx PI/2;
            }
            torus (outerStopperRadius, radius) {
                translate Z*(length-outerStopperRadius);
            }
        }
        cylinder (.5*openingWidth, [-radius-EPSILON, 0, length-openingDepth], [radius+EPSILON, 0, length-openingDepth]);
        box {
            translate [-.5, -.5, 0];
            scale [2*(radius+outerStopperRadius+EPSILON), openingWidth, openingDepth+EPSILON];
            translate Z*(length-openingDepth);
        }
    }
}

def legopieceTechnicPin ()
{
    middleStopperRadius = .38*LU;
    middleStopperLength = .15*LU;
    innerRadius = .22*LU;
    return difference {
        union {
            legopieceTechnicPin0 (LU-.5*middleStopperLength) {
                translate Z*.5*middleStopperLength;
            }
            legopieceTechnicPin0 (LU-.5*middleStopperLength) {
                rotx PI;
                translate -Z*.5*middleStopperLength;
            }
            roundedCylinder1 (middleStopperRadius, middleStopperLength, LEGO_ROUNDING) {
                rotx PI/2;
                translate -Z*.5*middleStopperLength;
            }
        }
        roundedCylinder3 (innerRadius, 2*LU, LEGO_ROUNDING) {
            translate -Y*LU;
            rotx PI/2;
        }
        bbox {
            scale 2;
            translate [-1, -1, -1];
            scale [middleStopperRadius, middleStopperRadius, LU];
        }
        translate [LU, .7*LU, 0];
    }
}

#endif // LEGO_PIECES_TRACI
